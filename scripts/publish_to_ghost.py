#!/usr/bin/env python3
"""
Board Watch — Publish to Ghost CMS
Creates a *draft* post on Ghost so you can review it before publishing.
"""

import argparse
import json
import logging
import os
import time
from datetime import datetime, timedelta, timezone
from pathlib import Path

import db

from dotenv import load_dotenv
import jwt
import markdown

load_dotenv()
import requests

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s  %(levelname)-8s  %(message)s",
)
log = logging.getLogger(__name__)

PROJECT_ROOT = Path(__file__).resolve().parent.parent
DRAFTS_DIR = PROJECT_ROOT / "data" / "drafts"
LOGO_PATH = PROJECT_ROOT / "assets" / "logo.png"

INTRO_HEADER = (
    "<p><strong>Lebo Board Watch</strong> is an AI-generated weekly digest of Mt. Lebanon local government "
    "meetings — school board, municipal commission, and more — so busy residents can stay informed without "
    "sitting through hours of public meetings. New editions drop every Sunday morning.</p>\n\n"
    "---\n\n"
)

MONETIZATION_FOOTER = (
    "\n\n---\n\n"
    "<p>Keep Lebo Watch running: "
    '<a href="https://buymeacoffee.com/leboboardwatcher">Buy Me a Coffee</a>.</p>\n'
    "<p><em>This newsletter was generated by AI. If something's wrong, blame the robot.</em></p>"
)

# ---------------------------------------------------------------------------
# Ghost Admin API auth
# ---------------------------------------------------------------------------


def _make_ghost_token(admin_key: str) -> str:
    """
    Create a short-lived JWT for the Ghost Admin API.

    The GHOST_ADMIN_KEY is formatted as ``{id}:{secret}`` where *secret* is
    a hex-encoded 256-bit key.
    """
    key_id, secret_hex = admin_key.split(":")
    secret_bytes = bytes.fromhex(secret_hex)

    now = int(datetime.now(timezone.utc).timestamp())
    payload = {
        "iat": now,
        "exp": now + 5 * 60,  # 5-minute expiry
        "aud": "/admin/",
    }
    headers = {"alg": "HS256", "typ": "JWT", "kid": key_id}

    return jwt.encode(payload, secret_bytes, algorithm="HS256", headers=headers)


# ---------------------------------------------------------------------------
# Image upload
# ---------------------------------------------------------------------------


def upload_image(ghost_url: str, admin_key: str, image_path: Path) -> str | None:
    """
    Upload an image to Ghost and return its public URL.

    Returns None if the upload fails.
    """
    token = _make_ghost_token(admin_key)
    api_endpoint = f"{ghost_url.rstrip('/')}/ghost/api/admin/images/upload/"
    headers = {
        "Authorization": f"Ghost {token}",
        "Accept-Version": "v5.0",
    }

    try:
        with open(image_path, "rb") as f:
            files = {"file": (image_path.name, f, "image/png")}
            resp = requests.post(
                api_endpoint, headers=headers, files=files, timeout=30
            )
        resp.raise_for_status()
        image_url = resp.json()["images"][0]["url"]
        log.info("Uploaded image: %s", image_url)
        return image_url
    except Exception as exc:
        log.warning("Image upload failed: %s", exc)
        return None


# ---------------------------------------------------------------------------
# Draft creation
# ---------------------------------------------------------------------------


def build_html(markdown_content: str) -> str:
    """Convert markdown draft to full HTML with intro header and footer."""
    html_body = INTRO_HEADER
    html_body += markdown.markdown(markdown_content, extensions=["extra", "smarty"])
    html_body += MONETIZATION_FOOTER
    return html_body


def save_html(html_body: str, draft_path: Path) -> Path:
    """Save the HTML version next to the markdown draft for easy copy-paste."""
    html_path = draft_path.with_suffix(".html")
    html_path.write_text(html_body, encoding="utf-8")
    log.info("Saved HTML copy: %s", html_path.name)
    return html_path


def create_draft(markdown_content: str, ghost_url: str, admin_key: str, feature_image_url: str | None = None) -> dict:
    """
    Post a draft to Ghost.

    Returns the JSON response from the Ghost Admin API (includes the post URL).
    """
    token = _make_ghost_token(admin_key)

    html_body = build_html(markdown_content)

    # Ghost expects content wrapped in a mobiledoc JSON structure
    mobiledoc = json.dumps(
        {
            "version": "0.3.1",
            "markups": [],
            "atoms": [],
            "cards": [["html", {"cardName": "html", "html": html_body}]],
            "sections": [[10, 0]],
        }
    )

    # Generate a weekly digest title using today's publish date
    today = datetime.now()
    title = f"Lebo Board Watch — {today.strftime('%B %d, %Y')}"

    post_body = {
        "title": title,
        "mobiledoc": mobiledoc,
        "status": "draft",
        "tags": [
            {"name": "Board Watch"},
            {"name": "Mt. Lebanon"},
        ],
    }
    if feature_image_url:
        post_body["feature_image"] = feature_image_url

    post_data = {"posts": [post_body]}

    api_endpoint = f"{ghost_url.rstrip('/')}/ghost/api/admin/posts/"
    headers = {
        "Authorization": f"Ghost {token}",
        "Content-Type": "application/json",
        "Accept-Version": "v5.0",
    }

    # Retry with exponential backoff for transient errors (502, 503, 504)
    max_retries = 3
    for attempt in range(1, max_retries + 1):
        # Generate a fresh token for each attempt (they expire after 5 min)
        if attempt > 1:
            token = _make_ghost_token(admin_key)
            headers["Authorization"] = f"Ghost {token}"

        resp = requests.post(api_endpoint, headers=headers, json=post_data, timeout=120)
        if resp.ok:
            return resp.json()

        if resp.status_code in (502, 503, 504) and attempt < max_retries:
            wait = 10 * attempt
            log.warning(
                "Ghost API returned %d (attempt %d/%d) — retrying in %ds…",
                resp.status_code, attempt, max_retries, wait,
            )
            time.sleep(wait)
            continue

        log.error("Ghost API error %d: %s", resp.status_code, resp.text[:500])
        resp.raise_for_status()

    # Should not reach here, but just in case
    resp.raise_for_status()
    return resp.json()


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------


def _find_latest_draft() -> Path | None:
    """Return the most recently modified .md file in data/drafts/."""
    if not DRAFTS_DIR.exists():
        return None
    files = sorted(DRAFTS_DIR.glob("*.md"), key=lambda p: p.stat().st_mtime, reverse=True)
    return files[0] if files else None


def main():
    parser = argparse.ArgumentParser(
        description="Board Watch — Publish draft to Ghost CMS"
    )
    parser.add_argument(
        "--file",
        default=None,
        help="Path to a markdown draft. Defaults to the most recent file in data/drafts/.",
    )
    parser.add_argument(
        "--no-image",
        action="store_true",
        default=False,
        help="Skip feature image upload.",
    )
    args = parser.parse_args()

    ghost_url = os.environ.get("GHOST_API_URL")
    admin_key = os.environ.get("GHOST_ADMIN_KEY")

    # Resolve the file to publish
    if args.file:
        draft_path = Path(args.file)
    else:
        draft_path = _find_latest_draft()

    if not draft_path or not draft_path.exists():
        log.error("No draft file found. Run scripts/analyze_meeting.py first.")
        raise SystemExit(1)

    log.info("Publishing draft: %s", draft_path.name)
    md_content = draft_path.read_text(encoding="utf-8")

    # Strip the generated-timestamp HTML comment (not needed in the published post)
    import re
    md_content = re.sub(r"<!--.*?-->\s*", "", md_content, flags=re.DOTALL)

    # Always save an HTML copy for easy copy-paste into Ghost
    html_body = build_html(md_content)
    html_path = save_html(html_body, draft_path)

    print("\n" + "=" * 60)
    print(f"  HTML saved: {html_path}")
    print("  Copy-paste this file into Ghost's HTML editor.")
    print("=" * 60 + "\n")

    # Publish to Ghost API if credentials are available
    if not ghost_url or not admin_key:
        log.warning("GHOST_API_URL or GHOST_ADMIN_KEY not set — skipping Ghost API publish.")
        log.info("HTML file is ready for manual copy-paste: %s", html_path)
        return

    # Upload the logo as the feature image
    feature_image_url = None
    if not args.no_image and LOGO_PATH.exists():
        log.info("Uploading feature image: %s", LOGO_PATH.name)
        feature_image_url = upload_image(ghost_url, admin_key, LOGO_PATH)
    elif args.no_image:
        log.info("Skipping feature image upload (--no-image)")

    try:
        result = create_draft(md_content, ghost_url, admin_key, feature_image_url=feature_image_url)
    except Exception as exc:
        log.error("Ghost API publish failed: %s", exc)
        log.info("HTML file is ready for manual copy-paste: %s", html_path)
        return

    post = result["posts"][0]
    post_url = post.get("url", "")
    post_id = post.get("id", "")
    preview_url = f"{ghost_url.rstrip('/')}/p/{post.get('uuid', post_id)}/"

    print("\n" + "=" * 60)
    print("Draft created successfully!")
    print(f"  Title:   {post.get('title')}")
    print(f"  Status:  {post.get('status')}")
    print(f"  URL:     {post_url}")
    print(f"  Preview: {preview_url}")
    print("=" * 60 + "\n")
    print("Open the preview link above to review before publishing.")

    # Record newsletter in Supabase
    if db.is_enabled():
        today = datetime.now()
        monday = today - timedelta(days=today.weekday())
        week_of = monday.strftime("%Y-%m-%d")
        title = post.get("title", f"Lebo Board Watch — {today.strftime('%B %d, %Y')}")
        db.upsert_newsletter(
            week_of=week_of,
            title=title,
            markdown_content=md_content,
            ghost_post_id=post_id,
            ghost_post_url=post_url,
        )
        log.info("Newsletter recorded in Supabase for week of %s", week_of)


if __name__ == "__main__":
    main()
